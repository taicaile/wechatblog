# Cyber Security 开发系列

## 揭秘非对称加密：你的数字身份守护者

-----

在这个数字时代，我们每天都在线上冲浪、购物、聊天，但你有没有想过，这些信息在传输过程中是如何确保安全的？今天，我们就来聊聊一个超级重要的概念——**非对称密钥加密**，以及它是如何守护你的数字世界的。

-----

### 1\. 非对称密钥：一把锁，两把钥匙？

想象一下，你有一把非常特别的锁。这把锁有两把钥匙，一把叫**公钥**，另一把叫**私钥**。它们是数学上紧密关联但又各自独立的。

* **公钥 (Public Key)**：顾名思义，可以**公开**给任何人。就像你的门牌号，大家都知道，但光有门牌号可进不了你家。
* **私钥 (Private Key)**：这把钥匙，你必须**严密保管**，绝不能让别人知道。它是你数字世界的“万能钥匙”，一旦泄露，后果不堪设想。

非对称密钥的原理就在于：用一把钥匙加密的数据，**只能用另一把钥匙来解密**。这为我们提供了前所未有的安全性和灵活性。

-----

### 2\. 私钥和公钥是“一对一”的吗？

是的，**私钥和公钥是严格“一对一”的**。它们就像是双胞胎，虽然长得不一样，但血缘关系密不可分。每一对密钥都是独一无二的，它们共同构成了你的数字身份标识。

-----

### 3\. 从私钥能获取到公钥吗？

**能！**

这是一个非常重要的特性。当你生成一套非对称密钥时，通常是先生成私钥，然后公钥就可以从这个私钥中派生出来。这个过程是单向且确定的：无论你派生多少次，同一个私钥都会得到完全相同的公钥。

所以，你可以放心地把你的公钥分享给任何人，因为他们无法通过公钥反推出你的私钥。

-----

### 4\. 从公钥能获取到私钥吗？

**不能！**

这正是非对称加密最神奇也最安全的地方。从公钥推导出私钥在计算上是**极其困难，甚至可以认为是不可行**的。

这依赖于复杂的数学难题（比如大整数分解或椭圆曲线上的离散对数问题）。目前，在现有计算机的算力下，要逆向推导私钥所需的时间和资源，几乎是一个天文数字，所以你大可不必担心有人通过你的公钥就能“偷走”你的私钥。

-----

### 5\. 签名是怎么实现的？

除了加密，非对称密钥更常用于**数字签名**，它能解决两个核心问题：

* **身份验证 (Authentication)**：确保信息确实是你发送的，而不是别人冒充的。
* **数据完整性 (Integrity)**：确保信息在传输过程中没有被篡改。

签名过程大致是这样的：

1. **生成数字指纹 (哈希值)**：首先，对原始信息（比如一封邮件、一份文件）进行一次特殊的“指纹识别”，也就是计算它的**哈希值**。这个哈希值是信息的一个独一无二的简短摘要，无论信息多大，哈希值都是固定长度。即使原始信息只改动一个标点符号，哈希值也会天差地别。
2. **私钥加密哈希值**：然后，你使用自己的**私钥**对这个哈希值进行加密。加密后的哈希值，就是你的**数字签名**。
3. **发送数据 + 签名**：最后，你将原始信息和这个数字签名一起发送给接收方。

-----

### 6\. 用私钥签名，用公钥验证签名的原理？

现在，我们把前面所有知识串联起来，看看验证签名是怎么回事：

1. **接收方获取原始信息和签名**：接收方收到你发来的原始信息和数字签名。
2. **用你的公钥解密签名**：接收方使用你的**公钥**来解密你发送的数字签名，从而得到你当时计算的那个哈希值。
3. **接收方独立计算哈希值**：同时，接收方也会对收到的原始信息独立地计算一遍哈希值。
4. **比对两个哈希值**：
      * 如果接收方自己计算的哈希值，和用你公钥解密出来的哈希值**完全一致**，那么恭喜你！这说明：
          * **信息没有被篡改**：因为任何篡改都会导致哈希值不匹配。
          * **信息确实是你发送的**：只有你的私钥才能生成这个有效的签名，你的公钥成功验证了它。这提供了强大的**不可否认性**。
      * 如果两个哈希值**不一致**，那么就意味着：信息可能被篡改了，或者签名是伪造的。

-----

### 7\. 动手实践：用 OpenSSL 体验签名和验证

理论知识讲完了，是不是有点抽象？别担心，我们现在就用强大的 OpenSSL 命令行工具来亲手体验一下非对称密钥的签名和验证过程。

假设我们要对一个名为 `message.txt` 的文件进行签名和验证。

#### 步骤 1: 生成 RSA 私钥

首先，我们需要生成一个 RSA 私钥。这里我们生成一个 2048 位的私钥，并保存为 `private_key.pem`。

```bash
openssl genrsa -out private_key.pem 2048
```

* `genrsa`: 生成 RSA 私钥的命令。
* `-out private_key.pem`: 指定输出文件名为 `private_key.pem`。
* `2048`: 指定密钥的长度，2048 位是目前常用的安全长度。

#### 步骤 2: 从私钥中提取公钥

为了让其他人能够验证你的签名，你需要把你的公钥给他们。我们从刚才生成的私钥中提取公钥，并保存为 `public_key.pem`。

```bash
openssl rsa -in private_key.pem -pubout -out public_key.pem
```

* `rsa`: OpenSSL 中处理 RSA 密钥的工具。
* `-in private_key.pem`: 指定输入文件为私钥。
* `-pubout`: 表示输出的是公钥。
* `-out public_key.pem`: 指定输出文件名为 `public_key.pem`。

现在，你有了 `private_key.pem` (你的私钥，务必严格保密) 和 `public_key.pem` (你的公钥，可以公开分发)。

#### 步骤 3: 创建待签名的数据文件

我们创建一个简单的文本文件作为要签名的数据。

```bash
echo "Hello, this is a test message to be signed." > message.txt
```

#### 步骤 4: 计算哈希值并用私钥签名（生成数字签名）

这是生成数字签名的关键一步。OpenSSL 会先计算 `message.txt` 的 SHA-256 哈希值，然后用 `private_key.pem` 对这个哈希值进行加密，生成数字签名 `signature.sig`。

```bash
openssl dgst -sha256 -sign private_key.pem -out signature.sig message.txt
```

* `dgst`: 数字摘要（digest）工具。
* `-sha256`: 指定使用 SHA-256 哈希算法。
* `-sign private_key.pem`: 使用 `private_key.pem` 对哈希值进行签名。
* `-out signature.sig`: 将生成的数字签名保存到 `signature.sig` 文件中。
* `message.txt`: 待签名的数据文件。

现在，你有了 `message.txt` (原始数据) 和 `signature.sig` (数字签名)。你可以将这两个文件发送给接收方。

#### 步骤 5: 使用公钥验证数字签名

接收方收到 `message.txt` 和 `signature.sig` 后，需要使用你的 `public_key.pem` 来验证签名的有效性。

```bash
openssl dgst -sha256 -verify public_key.pem -signature signature.sig message.txt
```

* `-sha256`: 指定验证时使用的哈希算法，必须与签名时一致。
* `-verify public_key.pem`: 使用 `public_key.pem` 进行验证。
* `-signature signature.sig`: 指定要验证的数字签名文件。
* `message.txt`: 原始数据文件，OpenSSL 会重新计算它的哈希值进行比对。

#### 观察验证结果

* 如果一切正常，你将看到输出：`Verified OK`，表示签名验证成功，数据完整且来源可信。
* 如果 `message.txt` 被篡改过，或者 `signature.sig` 不正确，或者你使用了错误的公钥，你将看到输出：`Verification Failure`。

**动手试试看！** 你可以尝试在验证前修改 `message.txt` 中的内容，然后再次运行验证命令，看看结果是不是 `Verification Failure`。这将让你更直观地理解数字签名的强大之处。

-----

### 8\. 公钥哈希：智能设备中的空间优化

在一些资源受限的智能硬件（比如物联网设备、嵌入式控制器）中，存储空间常常非常宝贵。完整的**公钥**可能会占用数十到数百字节。为了节省存储在设备内部**一次性可编程（OTP）区域**的空间，一些控制器会采取一种巧妙的方法：只存储**公钥的哈希值**。

这种机制的工作原理是：

1. **OTP 区域存储公钥哈希**：在设备的 OTP 区域（通常是工厂烧录，不可修改），不存储完整的公钥，而是存储其计算出的哈希值（例如 SHA-256 值）。这个哈希值通常比完整的公钥小得多。
2. **镜像头部存储完整公钥**：设备的固件镜像（也就是程序代码）的头部会存储完整的**公钥**。
3. **启动时验证公钥**：设备启动时，会执行以下验证步骤：
      * 读取镜像头部的完整公钥。
      * 对读取到的完整公钥，在设备内部计算它的哈希值。
      * 将计算出的哈希值与存储在 OTP 区域的公钥哈希值进行**比对**。
4. **匹配成功后使用公钥**：只有当两个哈希值完全匹配时，控制器才会认为镜像头部的公钥是“合法”的，并将其作为后续验证固件签名的依据。如果哈希值不匹配，则可能拒绝加载固件。

这种方式的好处是：OTP 区域是高度安全且有限的存储空间，存储一个较小的哈希值可以有效节省资源。而完整的公钥可以在固件更新时灵活地随镜像一起提供。这种方法兼顾了安全性（OTP 里的哈希值确保了公钥的真实性）和空间效率。

-----

非对称密钥加密技术是构建现代网络信任和安全的基础。从你登录银行网站、发送加密邮件，到软件下载时的完整性校验，它都在默默守护着你的数字生活。
